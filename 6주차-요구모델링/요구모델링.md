- 요구사항을 소프트웨어 및 하드웨어 관점으로 대상을 정의하는 방법

## 🔽요구분석 & 요구모델링

- ***요구분석***은 문제의 시스템과 관련해 **고객의 요구를 만족시키기 위한 사양**, 시스템을 구축하기에 **충분한 정보를 제공하는 사양**을 작성하는 프로세스.
- ***요구 모델링***은 **요구분석 + 개발자 이해방식 고려**
    - 작업결과인 명세는 고객과 개발자가 동일한 방식으로 이해해야함.

> 요구분석의 주요목표는 구축중인 시스템에 대한 **형식적 또는 준 형식적 설명을 제공**하는 것

> 요구 모델링은 **고객과 개발자가 무엇이 개발되고 있는지에 동의하는 것을 주된 목적**으로 하는 요구 명세를 생성하는 것

# ✅요구모델링

- 요구분석 작업은 주로 다루는 문제 영역에 있는 것들 중에서 대상 시스템에 구현할 것들만을 골라 요구로 정의하는 작업
- 반면 **요구모델링은 개발자가 이해하는 솔루션 영역의 관점으로 요구를 표현하는 작업**

→ **즉 요구를만족하기 위해 대상 시스템이 가져야 할 동작이나 구조를 나타내는 것이 모델링**

**명세=인터페이스**

![](https://velog.velcdn.com/images/kansun12/post/bd574ef7-2513-4fbe-8c02-2b5d6b74fa9b/image.png)

### ✔모델링을 하는 이유

- **복잡함을 잘 관리**하기 위하여
- 형체가 없는 소프트웨어의 구조를 **시각화** 하기 위하여
- 다른 사람과 **커뮤니케이션 하기 위하여**
- 문제 도메인 및 제품 **요구 사항을 이해**하기 위하여
- **개발 중인 시스템을 이해**하기 위하여
- 구현하기 전에 **잠재적 솔루션을 실험**해보기 위하여
- **기존 시스템의 문서화**

### ✔관점과 추상화 수준

- 모델링에 있어서 가장 중요한 것은 추상화
- **모델은 특정관점과 추상화(단순) 수준에 따라 달라짐.**

## 🔽소프트웨어와 모델링

- 소프트웨어 모델링은 거의 다 그래픽 기호와 주석으로 구성됨
  ![](https://velog.velcdn.com/images/kansun12/post/c9158f80-5576-4d4b-8c4d-dd48784ad600/image.png)

- 추상 수준 : 구체적, 추상적
- **관점 : 비즈니스 프로세스, 구조적, 동작측면(작동)**

### ✔모델 사이의 관계

![](https://velog.velcdn.com/images/kansun12/post/8ee92488-b12b-46d2-9034-1e2b71867640/image.png)

# ✅UML(Unified Modeling Language)

- 객체지향 소프트웨어를 모델링 하는 표준 그래픽 언어
    - 시스템의 여러측면을 그림으로 모델링, 하드웨어의 회로도 같은 의미
- UML은 소프트웨어 모델링의 공통언어

## 🔽UML 다이어그램

- 시스템의 모델링은 기능적, 구조적, 동적 관점으로 구성

![](https://velog.velcdn.com/images/kansun12/post/32cf9bf5-ed73-4cb5-8b10-1bf6209ad30c/image.png)

*`구조 다이어그램`* : **정적 모델링(요소)**

*`동적 다이어그램, 인터랙션 다이어그램`* : **동적 모델링(과정)**

- 소프트웨어를 복잡하게 만드는 특성 중 하나는 정적, 동적 모델링을 모두 갖추고 있는 것

### ✔UML 모델링 과정

- 모델링 작업의 근본적인 목표는 시스템에 있어야 할 클래스와 그들의 관계를 찾아내는 것 → UML 클래스 다이어그램으로 표현
- **클래스란?**
    - 동일한 속성과 행위를 수행하는 객체의 집합
    - 객체를 생성하는 설계도
    - **즉, 클래스는 공통의 속성과 책임을 갖는 객체들의 집합이자 실제 객체를 생성하는 설계도**
    - 클래스는 “변화의 기본 단위”
- 클래스를 보다 세부적으로 나누면 **Entity 클래스, Boundary 클래스, Control 클래스**로 구분할 수 있다,

1. 요구를 **사용 사례로 정리하고 사용 사례 다이어그램을 작성**
2. **클래스 후보**를 찾아내고 **개념적인 객체 모형**을 작성
3. 사용 사례를 기초하여 **순서 다이어그램을 작성**
4. 클래스의 **속성, 오퍼레이션 및 클래스 사이의 관계를 찾아** 객체모형을 완성
5. 상태 다이어그램이나 액티비티 다이어그램 등 **다른 다이어그램을 추가하여 UML 모델**을 완성
6. **서브시스템을 파악**하고 **전체 시스템 구조를 설계**
7. **적당한 객체**를 찾아내거나 **커스텀화 또는 객체를 새로 설계**

## 🔽객체와 클래스

- 객체: 상태, 동작, 고유 식별자를 가진 모든 실체
- 클래스: 공통 속성을 공유하는 객체 집합에 대한 정의

### ✔객체지향 개념

- _**속성과 오퍼레이션**_
    - 객체란 필요한 자료 구조와 이에 수행되는 함수들을 가진 하나의 **독립된 존재**
    - 각 객체가 자료 구조를 갖는다는 것은 각 객체가 어떤 속성을 가지고 있다는 것을 의미
    - 예를 들어 그래픽 프로그램에서 하나의 점을 객체로 본다면 수평과 수직 위치가 자료이면서 그 값이 객체의 속성을 의미한다
    - 각 객체가 적용될 수 있는 연산을 갖는다는 것은 각 객체가 어떤 연산을 수행할 수 있는 능력을 갖고 있다는 것을 의미
        - 객체는 하나의 `변수`나 `자료구조`와는 구별

### ✔객체지향과 절차적 방법의 비교

- 객체지향은 주어진 문제 영역을 그 안에 존재하는 객체의 집합으로 보며, 객체들은 서로 정보를 주고받아 상호 작용한다고 여김

![](https://velog.velcdn.com/images/kansun12/post/2aa7af2f-c39c-43ba-b950-b693d15a778f/image.png)

***자료구조와 함수가 하나로 묶이는 것이 객체지향***

- `클래스` : **속성과 오퍼레이션을 캡슐화**
- `객체` : **클래스의 인스턴스**
- `인스탄스` : **같은 클래스에 속하는 개개의 객체**로, 하나의 클래스에서 생성된 객체를 의미

### ✔객체와 속성

- `객체` : **속성과 오퍼레이션을 가진 애플리케이션의 독립된 존재**
- `속성` : **객체의 특징**을 결정
- `객체의 구조` : 소프트웨어 모듈(객체) = 자료구조 + 함수
- **객체는 상태(state), 능력(behavior), 정체성(identity)을 가짐**
- `캡슐화` : 객체의 **속성 부분과 오퍼레이션 부분을 하나로 모아서 단위화, 정보은닉**

  ![](https://velog.velcdn.com/images/kansun12/post/09970860-1b1b-4bab-949a-2636b13d3b6b/image.png)

    - **`캡슐화의 정의`** : **속성과 관련된 오퍼레이션을 클래스 안에 묶어서 하나로 취급**하는 것
    - **`추상화의 수단`** : 객체의 속성, 오퍼레이션 등의 세부사항은 차후에 생각
    - **`정보은닉(information hiding)`** : 외부의 직접적 접근 불가, 일종의 블랙박스
    - 구현에 따라 선택 가능 → **문법 : public, private, protected**
- **`연관`** : 서비스를 제공하는 객체와 서비스를 요청하는 객체가 **상호작용하는 관계 (캡슐화를 통한 결과)**
- **`가시성`** : 객체의 접근 가능성(연관이 있다는 것을 볼 수 있도록하는..)
  ![](https://velog.velcdn.com/images/kansun12/post/0ac4c2c1-5ddf-42c7-950e-412a5371a7fc/image.png)

  **_서버와 클라이언트 (객체와 객체간의 관계)_**

- **`집합`** : 전체 개념(whole)과 부분 개념(part) 사이의 관계, 격납(containment)의 의미
  ![](https://velog.velcdn.com/images/kansun12/post/86ab0bdd-9082-4245-bcdb-a34c170e6d91/image.png)

- **`상속` : 일반화된 클래스가 갖는 속성과 연산을 하위 개념의 구체화된 클래스가 그대로 물려받는 것**
  ![](https://velog.velcdn.com/images/kansun12/post/a8867af7-9109-474e-8a87-44f3816c8473/image.png)

    - `복수상속 (multiple inheritance)` : 두 개 이상의 수퍼 클래스에서 상속 받음

      ![](https://velog.velcdn.com/images/kansun12/post/f3c68dd9-5af7-4393-91f3-32ef4af0a27a/image.png)

- **`다형성` : 같은 이름의 메시지를 다른 객체 또는 서브 클래스에 호출할 수 있는 특징**

## 🔽객체지향 키워드 : 클래스, 객체, 캡슐화, 상속, 다형성

- **클래스** : 추상((abstract) 표현 대상의 특징에 대한 서술) → **속성 + 오퍼레이션 ⇒ 캡슐화 된 것**
    - 프로시져 추상화(Procedural abstraction) : 함수
    - 데이터 추상화 (Data abstraction) : 구조체, 배열, 포인터
- **객체** : 실체(클래스의 인스턴스, 개개의 존재)
- **캡슐화** : ＇데이터’와 ‘데이터에 대한 조작＇을 묶는 것
- **상속** : 하나의 클래스가 가지고 있는 특징들을 그대로 다른 클래스가 물려받는 것
- **다형성** : 상속성의 계층을 따라서 각 클래스에 동일한 이름의 메소드를 사용할 수 있는 것(같은 명령을 각기 다른 객체에 줄 수 있다는 뜻)